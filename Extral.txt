ExtraL Commands
===============  extra list manipulation commands for Tcl
                 by Peter De Rijk (Universiteit Antwerpen) 

	- General list manipulation commands
	- Tagged lists
	- Date and time
	- Convenience functions
	- Other commands
	- Dbm frontend

General list manipulation commands
----------------------------------
lregsub ?switches? exp list subSpec
	does a regsub for each element in the list, and returns the resulting list.
	eg.
	% lregsub {c$} {afdsg asdc sfgh {dfgh shgfc} dfhg} {!}
	afdsg asd! sfgh {dfgh shgf!} dfhg
	% lregsub {^([^.]+)\.([^.]+)$} {start.sh help.ps h.sh} {\2 \1}
	{sh start} {ps help} {sh h}

lfind <mode> list pattern
	returns a list of all indices which match a pattern.
	<mode> can be -exact, -glob, or -regexp
	eg.
	% lfind -regexp {Ape Ball Field {Antwerp city} Egg} {^A}
	0 3

lsub list ?-exclude? [index list]
	create a sublist from a set of indices
	When -exclude is specified, the elements of which the indexes are not in the list 
	will be given.
	eg.
		% lsub {Ape Ball Field {Antwerp city} Egg} {0 3}
		Ape {Antwerp city}
		% lsub {Ape Ball Field {Antwerp city} Egg} -exclude {0 3}
		Ball Field Egg

lcor <referencelist> <list>
	gives the positions of the elements in list in the reference list. If an element is not
	found in the reference list, it returns -1. Elements are matched only once.
	% lcor {a b c d e f} {d b}
	3 1
	% lcor {a b c d e f} {b d d}
	1 3 -1

lmath calc ?list1? ?action? ?list2?
	makes calculations on lists. Action can be one of +, -, * or /
		eg.
		% lmath calc {1 2 3.2 4} + {1 2 3.2 4}
		2.0 4.0 6.4 8.0
lmath sum ?list?
	returns the sum of the numbers in the list
lmath min ?list?
	returns the minimum of the numbers in the list
lmath max ?list?
	returns the maximum of the numbers in the list
lmath cumul ?list?
	returns a list containing the cumulative sums of the numbers in the list
lmath incr ?list? ?value?
	returns a list containing the numbers in the list incremented by value


lmanip subindex ?list? ?pos?
	returns a list of the 'pos' element in each of the elements of the given list
	eg.
	% lmanip subindex {{a 1} {b 2} {c 3}} 1
	1 2 3

lmanip mangle ?list1? ?list2?
	mangles two lists into one
	eg.
	% lmanip mangle {a b c} {1 2 3}
	{a 1} {b 2} {c 3}

lmanip extract ?list? ?expression?
	tries to match each element in a list; if the element matches, it extracts the 
	parenthesised part. It returns a list of all extracted parts. If there was no match,
	an empty element is put in the list.
	eg. 
	% lmanip extract {Results {A: 50%} {B: 25%} {C: 25%}} { ([0-9+]+)\%}
		{} 50 25 25

lmanip remdup ?list?
	removes duplicates from list
	eg.
	% lmanip remdup {a b c a b d}
	a b c d

lmanip split ?list? -before/-after/-outside ?positions?
	splits a list at positions into sublists
	eg.
	% lmanip split {a b c d e} -before {1 3}
	a {b c} {d e}

lmanip join ?list? ?join string? ?position list?
	joins list elements at positions given in the ?position list?. When you
	specify all, all elements will be joined.
	eg.
	% lmanip join {a b c {a d} e} { } {0 2}
		{a b} {c a d} e
	% lmanip join {a b c {a d} e} {} {0 2}
		ab {ca d} e
	% lmanip join {a b c {a d} e} {} all
	abca de

lmanip lengths ?list?
	returns a list with the lengths of the elements
	eg.
	% lmanip lengths {abc abcdef}
	3 6

lmanip fill ?size? ?start? ??incr??
	fills a list of ?size? elements with ?start?; if ?incr? is given and ?size? is an integer, each element in the list will be the former incremented with ?incr?
	eg.
	% lmanip fill 4 "Hello world"
	{Hello world} {Hello world} {Hello world} {Hello world}
	% lmanip fill 5 2 2
	2 4 6 8 10
	% lmanip fill 5 10 -2
	10 8 6 4 2

lmerge ?list1? ?list2? ??spacing??
	merges two lists into one
	eg.
	% lmerge {a b c} {1 2 3}
	a 1 b 2 c 3
	% lmerge {a b c d} {1 2} 2
	a b 1 c d 2

lunmerge ?list? ??spacing?? ??var??
	unmerges items from a list to the result; the remaining items are stored
	in the given variable ?var?
	eg.
		% lunmerge {a 1 b 2 c 3}
		a b c
		% lunmerge {a b 1 c d 2} 2 var
		a b c d
		% set var
		1 2

lpop listName ?pos?
	returns the last element from a list, thereby removing it from the list.
	If pos is given it will return the pos element of the list.

lshift listName
	returns the first element from a list, thereby removing it from the list.

lload <filename>
	returns all lines in the specified files as a list 

lwrite ?file? ?list?
	writes a list to a file

lpush listName ?item? [position]
	opposite of lpop.

lunshift listName ?item?
	opposite of lshift: prepends ?item? to the list.

lset listName ?item? ?indexlist?
	sets all elements of the list at the given indices to value ?item?

larrayset array varlist valuelist
	sets the values of valuelist to the respective elements in varlist for
	the given array

lcommon list list ...
	returns the common elements of the lists

lunion list list ...
	returns the union of the lists

leor list1 list2
	returns the elements that are not shared between both lists

lremove listName ?item? ...
	removes the items from the list

laddnew listName ?item? ...
	adds the items to the list if not already there

literate variableName list
	debugging tool: to interactively iterate a variable over a list. literate
	is used to initialise and it puts the first element of the list into the
	variable. Every 'lnext variableName' will puts the next element into the 
	variable.

Tagged lists
------------
In a tagged list tags alternate with the value attached to this tag, 
eg.: {tag1 {value of tag1} tag2 {value of tag2} ...}
Using the tagged list commands, you can use a list as a sort of array.
However, tagged lists have some advantages to arrays:
 - They can be passed to functions easily
 - tagged lists can be nested: an element of a tagged list can 
   contain another tagged list, etc.
 - although finding a value in an array should be faster,
   creating the array can take more time.
 - tagged list can be handled according to a certain structure

taglset ?-struct schema? list taglist value
taglget ?-struct schema? list taglist
taglunset list tag
taglfields list ?valueVar?
	examples.:
	set the value for tag
		% set list {a 1 b 4}
		a 1 b 4
		% set list [taglset $list c 3]
		a 1 b 4 c 3
		% taglset {a 1 b 4 c 3} b 2
		a 1 b 2 c 3
	example of nesting:
		% taglset {a 1 b {a 1 b 4} c 3} {b b} 2
		a 1 b {a 1 b 2} c 3
	example of structure:
		% set struct {
			reg {*regexp {^a[0-9]} ?}
			sub {
				a {*any ?}
				b {*between 0 10 ?}
			}
			ints {
				* {*int ?}
			}
		}
		% set data {}
		% set data [taglset -struct $struct $data {sub b} 9]
		sub {b 9}
		% set data [taglset -struct $struct $data {sub b} 11]
		error: 11 is not between 0 and 10
		% set data [taglset -struct $struct $data ints {a 9}]
		sub {b 9} ints {a 9}
		% set data [taglset -struct $struct $data {sub b} ?]
		ints {a 9}
		% taglget -struct $struct $data {sub b}
		?

Date and time
-------------
	The scantime transforms a string containing date and/or time into a 
	double value (number of seconds since 0). These values can
	be sorted, compared or stored, and transformed back into a human readable
	date and time string using the formattime command. The clock scan and
	format commands in Tcl give up before somewhere before 1901 and after
	2037, which is a bit of a bummer (eg. for genealogy). The transformation
	takes into account leap-years properly (I hope). However, it extrapolated
	the current rule to the past (so eg. 0004 BC is a leap year), and doesn't
	take into account the meddling that has happened to time over 
	time (missing days, ...). I don't know enough about that to do this
	correctly.

	scantime time ?date/time/both?
		!! the year should be specified fully (>=4 numbers)
		eg.:
			% scantime {9 May 1997 12:30}
			62998777800.0
	formattime time ?formatstring?
		!! not all options of clock scan are supported
		%% : %
		%Y : year
		%d : day (09)
		%e : day (9)
		%j : day of year
		%m : month number
		%b : abbreviated month name
		%B : full month name
		%H : hour
		%M : minute
		%S : second
		%s : hundreds of a second
		eg.:
			% formattime 62998777800.0
			1997 May 09 12:30:00
			% formattime 62998777800.0 "%B %e %Y"
			May 9 1997

Struct
------
	This code emulates structures in a way. all data is actually stored in 
	one global array extraL__Struct. You cannot use the generic array command 
	on structure structure members
Commands are:
struct new
	returns an unused pointer to a structure.
	eg.
		set current [struct new]

struct set struct->member value
	sets the value of a member
	eg.
		struct set $current->field Test
		struct set $current->data(a) 1
	
struct value struct->member
	returns the value of a member
	eg.
		struct value $current->field
		struct value $current->data(a)

struct unset struct?->member?
	unsets a member or the entire struct
	eg.
		struct unset $current->field
		struct unset $current

struct var struct?->member?
	gives the actual variable name where the member is stored (global): 
	This can be used in -textvariable options etc.
	eg.
		entry .try -textvariable [struct var $current->field]
		pack .try

struct arrayset struct->member items values
	sets values in an array member
	eg.
		% struct arrayset $current->value {a b c} {1 2 3}
		% struct value $current->value(b)
		2

struct arrayget struct->member
		% struct arrayget $current->value
	b 2 a 1 c 3

struct arraynames struct->member
		% struct arraynames $current->value
	b a c

struct arraysize struct->member
		% struct arraysize $current->value
	3

Some convenience functions
--------------------------
rem:
	does nothing
	I use this to put some example or testing code in a program
	without all the #'s
REM
	when the procedure remof is called, REM will also do nothing
	when the procedure remon is called, REM will put its arguments
	to the stdout
true expr
	returns 1 when expr is yes, true or 1

Filing commands
---------------
These will disappear as Tcl now has these commands in the file command
commands to mimick (for some part) the Unix filing commands. Under Unix, they
call the actual Unix commands after doing wildcart substitution. Under Windows
functionality is more limited.
mkdir		make a directory
ls		list files
chmod		change permissions
cp		copy files
mv		move files
rm		remove files

Other commands
--------------
leval command $args
	converted the leval patch by Viktor Dukhovni <viktor@esm.com> to
	a dynamically loadable version:
	This command is a fast light "eval" specifically designed to execute
	zero or more Tcl lists (concatenated) by invoking the command specified
	by the first list element, with the remaining list elements as "literal"
	arguments.  No variable or command substitution takes place on the
	arguments.

atexit add command
	adds a command to the atexit handler: This command will be executed when
	the program exits. It can be used to do a cleanup. This command redefines
	the exit command. If you use it in Tk, and you exit by calling "destroy ."
	it will not work. You can redefine the destroy command to call exit when it 
	has . as an argument.

tempfile ?get?
	creates an (empty) temporary file and returns its name. You should remove
	the temporary file when not used any longer. However, leftover temporary 
	files will be removed by an atexit handler

tempfile clean
	remove all temporary files for the running program.

ffind <switches> filelist pattern ?varName? ?pattern? ?varname?
	returns the files in filelist whose content match the given pattern.
	if varName is given, the results will be stored in this variable.
	several patterns can be searched, the results for each being stored
	in the apropriate variable.
	<switches> can be -matches, -all -exact, -glob, or -regexp
		-matches    : the text matched by the bracketed part of 
		              the pattern will be mangled into the result. 
		-allmatches : all matches in the file will be returned in
		              the form of: 
		              file1 match1 file1 match2 file2 match2
		-allfiles   : see next
ffind -matches -allfiles <switches> filelist pattern nulvalue ?varName? ?pattern? ?nulvalue? ?varname? ..
	ffind with these options will return a list containing one element
	for each file in the filelist. if the pattern was found in a file,
	the the element contains the match; if it was not found, it will
	contain the nulvalue. This is not compatible with the -allmatches
	options

ssort ?-ascii? ?-integer? ?-real? ?-increasing? ?-decreasing? ?-dictionary? ?-command string? ?-reflist list? list
	enhanced lsort:
		by D. Richard Hipp -- drh@tobit.vnet.net -- 704.948.4565 :
			- re-entrant and thread-safe: eg. ssort can be used in its
			  own -command proc
				- 10% faster
			- option -dictionary: Using -dict, "B" comes in between
			  "a" and "b".  Also "x10" comes after "x9" 
		by Peter De Rijk :
			extra option -reflist: sort the elements in the list according
			to the comparisons of the corresponding elements in the 
			reflist.

Dbm frontend
------------
dbm support that can have different backends: availble backend systems are
	fdbm: file system based; slow but easy, relatively safe and very portable
	gdbm: using the gdbm routines; as a loadable module (gdbm.so)
	bsddbm: using the bsd db routines; as a loadable module (bsddbm.so)
			 this seems to be the faster and most reliable than gdbm
New backends can be added (in C) using the ExtraL_DbmCreateType function.
The database code can also be used from C using the ExtraL_DbmOpen function.

dbm command
	dbm types
		list the available type of database systems; fdbm is provided,
		gdbm and bsddbm are dynamically loadable
	dbm create type database ?mode?
		create a database of the given type (fdbm, gdbm, bsddbm) in 
		the "file" database. the optional mode gives the permissions 
		in integer form. The database is not opened by this command.
	dbm open type dbcmd database ?read/write?
		open a database for reading (read = default) or reading and 
		writing (write).
		type: the type of the database (fdbm, gdbm, bsddbm).
		dbcmd: the command by which the opened database can be queried
		database: place of the database in the filing system
database commands: The dbmcmd created by the "dbm create" above will 
have the following options:
	dbmcmd set key value
		set key in the database to value.
	dbmcmd get key
		get the value associated with key from the database.

<HEAD>
<TITLE>Extra list manipulation commands</TITLE>
</HEAD>
<BODY>
<h1>Extra list manipulation commands</h1>

<dl><b><dt>
list_remove listName ?item? ...
</b><dd>
removes the items from the list

<b><dt>
list_push listName ?item? ?position?
</b><dd>
	opposite of list_pop.

<b><dt>
list_unshift listName ?item?
</b><dd>
	opposite of list_shift: prepends ?item? to the list.

<b><dt>
list_set listName ?item? ?indexlist?
</b><dd>
	sets all elements of the list at the given indices to value ?item?

<b><dt>
list_arrayset array varlist valuelist
</b><dd>
	sets the values of valuelist to the respective elements in varlist for
	the given array

<b><dt>
list_common list list ...
</b><dd>
	returns the common elements of the lists

<b><dt>
list_union list list ...
</b><dd>
	returns the union of the lists

<b><dt>
list_eor list1 list2
</b><dd>
	returns the elements that are not shared between both lists

<b><dt>
list_addnew listName ?item? ...
</b><dd>
	adds the items to the list if not already there

<b><dt>
inlist list value
</b><dd>
returns 1 if $value is an element of list $list
returns 0 if $value is not an element of list $list

<b><dt>
list_load filename
</b><dd>
	returns all lines in the specified files as a list 

<b><dt>
list_write file list
</b><dd>
	writes a list to a file

<b><dt>
list_append list ?list1? ...
</b><dd>
	appends elements in list1 (and following) to list
<br>eg.:<pre>
   % set list {1 2 3}
   1 2 3
	% list_append list {3 4} {5 6}
	% set list
   1 2 3 4 5 6
</pre>
<b><dt>
list_regsub ?switches? exp list subSpec
</b><dd>
	does a regsub for each element in the list, and returns the resulting list.
<br>eg.:<pre>
	% list_regsub {c$} {afdsg asdc sfgh {dfgh shgfc} dfhg} {!}
	afdsg asd! sfgh {dfgh shgf!} dfhg
	% list_regsub {^([^.]+)\.([^.]+)$} {start.sh help.ps h.sh} {\2 \1}
	{sh start} {ps help} {sh h}
</pre>
<b><dt>
list_subindex ?list? ?pos?
</b><dd>
	returns a list of the 'pos' element in each of the elements of the given list
<br>eg.:<pre>
	% list_subindex {{a 1} {b 2} {c 3}} 1
	1 2 3
</pre>
<b><dt>
list_mangle ?list1? ?list2?
</b><dd>
	mangles two lists into one
<br>eg.:<pre>
	% list_mangle {a b c} {1 2 3}
	{a 1} {b 2} {c 3}
</pre>
<b><dt>
list_extract ?list? ?expression?
</b><dd>
	tries to match each element in a list; if the element matches, it extracts the 
	parenthesised part. It returns a list of all extracted parts. If there was no match,
	an empty element is put in the list.
<br>eg.:<pre> 
	% list_extract {Results {A: 50%} {B: 25%} {C: 25%}} { ([0-9+]+)\%}
		{} 50 25 25
</pre>
<b><dt>
list_split ?list? -before/-after/-outside ?positions?
</b><dd>
	splits a list at positions into sublists
<br>eg.:<pre>
	% list_split {a b c d e} -before {1 3}
	a {b c} {d e}
</pre>
<b><dt>
list_join ?list? ?join string? ?position list?
</b><dd>
	joins list elements at positions given in the ?position list?. When you
	specify all, all elements will be joined.
<br>eg.:<pre>
	% list_join {a b c {a d} e} { } {0 2}
		{a b} {c a d} e
	% list_join {a b c {a d} e} {} {0 2}
		ab {ca d} e
	% list_join {a b c {a d} e} {} all
	abca de
</pre>
<b><dt>
list_lengths ?list?
</b><dd>
	returns a list with the lengths of the elements
<br>eg.:<pre>
	% list_lengths {abc abcdef}
	3 6
</pre>
<b><dt>
list_subindex ?list? ?pos?
</b><dd>
	selects all elements of a list that match a certain pattern. Default mode is -glob
<br>eg.:<pre>
	% list_select {a b ab bc} a*
	a ab
	% list_select -regexp {a ab aa bc} {^[ab]*$}
	a ab aa
</pre>
</body>

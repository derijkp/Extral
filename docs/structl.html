<HEAD>
<TITLE>
Structured lists
</TITLE>
</HEAD>
<BODY>
<h1>
Structured lists
</h1>

In a structured list names alternate with the value attached to this name,
eg.: {name1 {value of name1} name2 {value of name2} ...}
Using the structured list commands, you can use a list as a sort of array.
However, structured lists have some advantages to arrays:
<ul>
<li>They can be passed to functions easily
<li>structured lists can be nested: an element of a structured list can
   contain another structured list, etc.
<li>although finding a value in an array should be faster,
   creating the array can take more time.
<li>structured list can be handled according to a certain schema using the -struct option.
</ul>
 Using structured lists, data can be stored in a treelike structure (see examples further down).
 Using the struclget and structlset functions, data in any of the branches or leaves can be
 easily obtained or set, using a field (a list of names of successive branches).
 <p>
 Using the -struct option a schema can be specified that puts constraints on which branches are 
 allowed, and what values are allowed in the branches.
 A schema is also organised as a structured list. when the first element in a value starts with 
 an asterisk, it is an endnode. Otherwise it is the schema of the substructure starting
 at the name of that value.
 An endnode consists of a type indicator (the first element starting with an asterisk) and 
 type parameters. A number of types 
 are available by default (*any, *int, *regexp, *date, *named *list, ...). 
 New types can be added using either Tcl or C code.
 <p>
 If a schema contains names consisting of a list where element 0 is a questionmark these are treated specially: 
 The list must have 2 further elements: element 1 is the long name for the value, and element
 2 the short name. Both long and short name can be used to set or get values from the structured list.
 However, structlset will always return a struct with the short name (efficient storage), while
 structlget will return the long form.

<dl><b><dt>
structlset ?-struct schema? ?-data clientdata? list field value ?field value ...?
</b><dd>
 set the value of a field in the structured list. The -data option can be used to
 pass data to self defined data types.
<br>eg.:<pre>
	set the value for tag
		% set list {a 1 b 4}
		a 1 b 4
		% set list [structlset $list c 3]
		a 1 b 4 c 3
		% structlset {a 1 b 4 c 3} b 2
		a 1 b 2 c 3
	example of nesting:
		% structlset {a 1 b {a 1 b 4} c 3} {b b} 2
		a 1 b {a 1 b 2} c 3
	example of structure:
		% set struct {
			reg {*regexp {^a[0-9]} ?}
			sub {
				a {*any ?}
				b {*between 0 10 ?}
			}
			ints {
				*named {*int ?}
			}
		}
		% set data {}
		% set data [structlset -struct $struct $data {sub b} 9]
		sub {b 9}
		% set data [structlset -struct $struct $data {sub b} 11]
		error: 11 is not between 0 and 10 at field "b" at field "sub"
		% set data [structlset -struct $struct $data ints {a 9}]
		sub {b 9} ints {a 9}
		% set data [structlset -struct $struct $data {sub b} ?]
		ints {a 9}
</pre>
<b><dt>
structlget ?-struct schema? list field ?field ...?
</b><dd>
get the value of a field in the structured list
<br>eg.:<pre>
	% set struct {
		reg {*regexp {^a[0-9]} ?}
		sub {
			a {*any ?}
			b {*between 0 10 ?}
		}
		ints {
			*named {*int ?}
		}
	}
	% structlget -struct $struct {ints {a 9}} {sub b}
	?
	% structlget -struct $struct {ints {a 9}} {ints}
	a 9
</pre>
<b><dt>
structlunset ?-struct schema? ?-data clientdata? list field ?field ...?
</b><dd>
unset the value of a field in the structured list
<br>eg.:<pre>
	% structlunset {a 1 b 2} b
	a 1
</pre>
<b><dt>
structlfields list field ?valueVar?
</b><dd>
returns the fields present in the structure list

</body>

<HEAD>
<TITLE>
General list manipulation commands
</TITLE>
</HEAD>
<BODY>
<h1>
General list manipulation commands
</h1>

<dl><b><dt>
lremove listName ?item? ...
</b><dd>
removes the items from the list

<b><dt>
lpush listName ?item? ?position?
</b><dd>
	opposite of lpop.

<b><dt>
lunshift listName ?item?
</b><dd>
	opposite of lshift: prepends ?item? to the list.

<b><dt>
lset listName ?item? ?indexlist?
</b><dd>
	sets all elements of the list at the given indices to value ?item?

<b><dt>
larrayset array varlist valuelist
</b><dd>
	sets the values of valuelist to the respective elements in varlist for
	the given array

<b><dt>
lcommon list list ...
</b><dd>
	returns the common elements of the lists

<b><dt>
lunion list list ...
</b><dd>
	returns the union of the lists

<b><dt>
leor list1 list2
</b><dd>
	returns the elements that are not shared between both lists

<b><dt>
laddnew listName ?item? ...
</b><dd>
	adds the items to the list if not already there

<b><dt>
oneof element list
</b><dd>
	returns 1 if the lement occurs in the list, 0 if it does not.

<b><dt>
lregsub ?switches? exp list subSpec
</b><dd>
	does a regsub for each element in the list, and returns the resulting list.
<br>eg.:<pre>
	% lregsub {c$} {afdsg asdc sfgh {dfgh shgfc} dfhg} {!}
	afdsg asd! sfgh {dfgh shgf!} dfhg
	% lregsub {^([^.]+)\.([^.]+)$} {start.sh help.ps h.sh} {\2 \1}
	{sh start} {ps help} {sh h}
</pre>
<b><dt>
lpop listName ?pos?
</b><dd>
	returns the last element from a list, thereby removing it from the list.
	If pos is given it will return the pos element of the list.

<b><dt>
lshift listName
</b><dd>
	returns the first element from a list, thereby removing it from the list.

<b><dt>
lsub list ?-exclude? [index list]
</b><dd>
	create a sublist from a set of indices
	When -exclude is specified, the elements of which the indexes are not in the list 
	will be given.
<br>eg.:<pre>
	% lsub {Ape Ball Field {Antwerp city} Egg} {0 3}
	Ape {Antwerp city}
	% lsub {Ape Ball Field {Antwerp city} Egg} -exclude {0 3}
	Ball Field Egg
</pre>
<b><dt>
lfind mode list pattern
</b><dd>
	returns a list of all indices which match a pattern.
	mode can be -exact, -glob, or -regexp
	The default mode is -exact
<br>eg.:<pre>
	% lfind -regexp {Ape Ball Field {Antwerp city} Egg} {^A}
	0 3
</pre>
<b><dt>
lcor <referencelist> <list>
</b><dd>
	gives the positions of the elements in list in the reference list. If an element is not
	found in the reference list, it returns -1. Elements are matched only once.
<br>eg.:<pre>
	% lcor {a b c d e f} {d b}
	3 1
	% lcor {a b c d e f} {b d d}
	1 3 -1
</pre>
<b><dt>
lremdup list
</b><dd>
returns a list in which all duplactes are removed
	with the -sorted option the command will usually be a lot faster,
	but $list must be sorted with lsort;
	The optional $var gives the name of a variable in which the removed items
	will be stored.

<b><dt>
llremove ?-sorted? list1 list2
</b><dd>
	returns a list with all items in list1 that are not in list2
	with the -sorted option the command will usually be a lot faster,
	but both given lists must be sorted with lsort;
	The optional $var gives the name of a variable in which the removed items
	will be stored.

<b><dt>
lmerge ?list1? ?list2? ??spacing??
</b><dd>
	merges two lists into one
<br>eg.:<pre>
	% lmerge {a b c} {1 2 3}
	a 1 b 2 c 3
	% lmerge {a b c d} {1 2} 2
	a b 1 c d 2
</pre>
<b><dt>
lunmerge ?list? ??spacing?? ??var??
</b><dd>
	unmerges items from a list to the result; the remaining items are stored
	in the given variable ?var?
<br>eg.:<pre>
	% lunmerge {a 1 b 2 c 3}
	a b c
	% lunmerge {a b 1 c d 2} 2 var
	a b c d
	% set var
	1 2
</pre>
<b><dt>
lreverse list
</b><dd>
 returns the reverse of the list.

</body>

ExtraL Commands
===============  extra list manipulation commands for Tcl
                 by Peter De Rijk (Universiteit Antwerpen) 

ffind <switches> filelist pattern
    returns a list of all files in filelist which match a pattern.
    <switches> can be -matches, -all, -allfiles -exact, -glob, or -regexp
    with -matches, the text matching the bracketed pattern will be mangled 
    into the result. With -all all matches in the file will be returned. 
	With -allfiles non matching files will return {}

lregsub ?switches? exp list subSpec
    does a regsub for each element in the list, and returns the resulting list.
    eg.
	% lregsub {c$} {afdsg asdc sfgh {dfgh shgfc} dfhg} {!}
	afdsg asd! sfgh {dfgh shgf!} dfhg
	% lregsub {^([^.]+)\.([^.]+)$} {start.sh help.ps h.sh} {\2 \1}
	{sh start} {ps help} {sh h}

lfind <mode> list pattern
    returns a list of all indices which match a pattern.
    <mode> can be -exact, -glob, or -regexp
    eg.
	% lfind -regexp {Ape Ball Field {Antwerp city} Egg} {^A}
	0 3

lsub list ?-exclude? [index list]
    create a sublist from a set of indices
    When -exclude is specified, the elements of which the indexes are not in the list 
    will be given.
	eg.
	    % lsub {Ape Ball Field {Antwerp city} Egg} {0 3}
	    Ape {Antwerp city}
	    % lsub {Ape Ball Field {Antwerp city} Egg} -exclude {0 3}
	    Ball Field Egg

lcor <referencelist> <list>
    gives the positions of the elements in list in the reference list. If an element is not
    found in the reference list, it returns -1. Elements are matched only once.
	% lcor {a b c d e f} {d b}
	3 1
	% lcor {a b c d e f} {b d d}
	1 3 -1

lload <filename>
    returns all lines in the specified files as a list 

lwrite ?file? ?list?
    writes a list to a file

lmath calc ?list1? ?action? ?list2?
    makes calculations on lists. Action can be one of +, -, * or /
        eg.
        % lmath calc {1 2 3.2 4} + {1 2 3.2 4}
        2.0 4.0 6.4 8.0
lmath sum ?list?
    returns the sum of the numbers in the list
lmath min ?list?
    returns the minimum of the numbers in the list
lmath max ?list?
    returns the maximum of the numbers in the list
lmath cumul ?list?
    returns a list containing the cumulative sums of the numbers in the list
lmath incr ?list? ?value?
    returns a list containing the numbers in the list incremented by value


lmanip subindex ?list? ?pos?
    returns a list of the 'pos' element in each of the elements of the given list
	eg.
	% lmanip subindex {{a 1} {b 2} {c 3}} 1
	1 2 3

lmanip merge ?list1? ?list2?
    merge two lists into one
	eg.
	% lmanip merge {a b c} {1 2 3}
	{a 1} {b 2} {c 3}

lmanip extract ?list? ?expression?
    tries to match each element in a list; if the element matches, it extracts the 
    parenthesised part. It returns a list of all extracted parts. If there was no match,
    an empty element is put in the list.
	eg. 
	% lmanip extract {Results {A: 50%} {B: 25%} {C: 25%}} { ([0-9+]+)\%}
        {} 50 25 25

lmanip remdup ?list?
    removes duplicates from list
	eg.
	% lmanip remdup {a b c a b d}
	a b c d

lmanip split ?list? -before/-after/-outside ?positions?
    splits a list at positions into sublists
	eg.
	% lmanip split {a b c d e} -before {1 3}
	a {b c} {d e}

lmanip join ?list? ?join string? ?position list?
    joins list elements at positions given in the ?position list?. When you
    specify all, all elements will be joined.
	eg.
	% lmanip join {a b c {a d} e} { } {0 2}
        {a b} {c a d} e
	% lmanip join {a b c {a d} e} {} {0 2}
        ab {ca d} e
	% lmanip join {a b c {a d} e} {} all
	abca de

lmanip lengths ?list?
    returns a list with the lengths of the elements
	eg.
	% lmanip lengths {abc abcdef}
	3 6

lmanip fill ?size? ?start? ??incr??
    fills a list of ?size? elements with ?start?; if ?incr? is given and ?size? is an integer, each element in the list will be the former incremented with ?incr?
	eg.
	% lmanip fill 4 "Hello world"
	{Hello world} {Hello world} {Hello world} {Hello world}
	% lmanip fill 5 2 2
	2 4 6 8 10
	% lmanip fill 5 10 -2
	10 8 6 4 2

lmanip mangle ?list1? ?list2? ??spacing??
    mangles two lists into one
	eg.
	% lmanip mangle {a b c} {1 2 3}
	a 1 b 2 c 3
	% lmanip mangle {a b c d} {1 2} 2
	a b 1 c d 2

lmanip unmangle ?list? ??spacing?? ??var??
    unmangles items from a list to the result; the remaining items are stored
    in the given variable ?var?
	eg.
        % lmanip unmangle {a 1 b 2 c 3}
        a b c
        % lmanip unmangle {1 a b 2 c d} 2 var
        1 2
        % set var
        a b c d

Commands in extral.tcl
----------------------
There are also some extra listprocessing commands written in tcl in the 
package. Some use the commands written in C:

lpop listName [position]
    returns the last element from a list, thereby removing it from the list.

lpush listName ?item? [position]
    for completeness, it is actually the same command as lappend.

lshift listName
    returns the first element from a list, thereby removing it from the list.

lunshift listName ?item?
    prepends ?item? to the list.

lset listName ?item? ?indexlist?
    sets all elements of the list at the given indices to value ?item?

larrayset array varlist valuelist
    sets the values of valuelist to the respective elements in varlist for
    the given array

leor list1 list2
    returns the elements that are not shared between both lists

lremove listName ?item? ...
    removes the items from the list

laddnew listName ?item? ...
    adds the items to the list if not already there

literate variableName list
    debugging tool: to interactively iterate a variable over a list. literate
    is used to initialise and it puts the first element of the list into the
    variable. Every 'lnext variableName' will puts the next element into the 
    variable.

struct
------
    This code emulates structures in a way. all data is actually stored in 
    one global array extraL__Struct. You cannot use the generic array command 
    on structure structure members
Commands are:
struct new
    returns an unused pointer to a structure.
    eg.
        set current [struct new]

struct set struct->member value
    sets the value of a member
    eg.
        struct set $current->field Test
        struct set $current->data(a) 1
    
struct value struct->member
    returns the value of a member
    eg.
        struct value $current->field
        struct value $current->data(a)

struct unset struct?->member?
    unsets a member or the entire struct
    eg.
        struct unset $current->field
        struct unset $current

struct var struct?->member?
    gives the actual variable name where the member is stored (global): 
    This can be used in -textvariable options etc.
    eg.
        entry .try -textvariable [struct var $current->field]
        pack .try

struct arrayset struct->member items values
    sets values in an array member
    eg.
        % struct arrayset $current->value {a b c} {1 2 3}
        % struct value $current->value(b)
        2

struct arrayget struct->member
        % struct arrayget $current->value
	b 2 a 1 c 3

struct arraynames struct->member
        % struct arraynames $current->value
	b a c

struct arraysize struct->member
        % struct arraysize $current->value
	3

Some convenience functions
--------------------------
rem:
    does nothing
    I use this to put some example or testing code in a program
    without all the #'s
REM
    when the procedure remof is called, REM will also do nothing
    when the procedure remon is called, REM will put its arguments
    to the stdout
true expr
    returns 1 when expr is yes, true or 1

Filing commands
---------------
commands to mimick (for some part) the Unix filing commands. Under Unix, they
call the actual Unix commands after doing wildcart substitution. Under Windows
functionality is more limited.
mkdir		make a directory
ls		list files
chmod		change permissions
cp		copy files
mv		move files
rm		remove files

Other commands
--------------
atexit add command
	adds a command to the atexit handler: This command will be executed when
	the program exits. It can be used to do a cleanup. This command redefines
	the exit command. If you use it in Tk, and you exit by calling "destroy ."
	it will not work. You can redefine the destroy command to call exit when it 
	has . as an argument.

tempfile ?get?
	creates an (empty) temporary file and returns its name. You should remove
	the temporary file when not used any longer. However, leftover temporary 
	files will be removed by an atexit handler

tempfile clean
	remove all temporary files for the running program.
